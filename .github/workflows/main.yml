import os

# Código de la PC Virtual
class VirtualPC:
    def __init__(self, memory_size=1024, tailscale_ip="100.100.100.100"):
        self.memory = [0] * memory_size
        self.registers = {
            'PC': 0,
            'ACC': 0
        }
        self.instructions = {
            'LOAD': self.load,
            'ADD': self.add,
            'STORE': self.store,
            'HALT': self.halt,
            'PRINT_IP': self.print_ip  # Nueva instrucción para mostrar la IP
        }
        self.running = True
        self.tailscale_ip = tailscale_ip  # IP de Tailscale asignada

    def load(self, address):
        address = int(address)
        self.registers['ACC'] = self.memory[address]
        self.registers['PC'] += 2

    def add(self, address):
        address = int(address)
        self.registers['ACC'] += self.memory[address]
        self.registers['PC'] += 2

    def store(self, address):
        address = int(address)
        self.memory[address] = self.registers['ACC']
        self.registers['PC'] += 2

    def halt(self, _):
        self.running = False
        self.registers['PC'] += 1

    def print_ip(self, _):
        """Muestra la IP de Tailscale."""
        print(f"Tailscale IP: {self.tailscale_ip}")
        self.registers['PC'] += 1

    def execute_instruction(self):
        if not self.running:
            return

        instruction = self.memory[self.registers['PC']]
        instruction = str(instruction)
        operand = self.memory[self.registers['PC'] + 1]

        if instruction in self.instructions:
            self.instructions[instruction](operand)
        else:
            print(f"Instrucción desconocida: {instruction}")
            self.running = False

    def load_program(self, program):
        address = 0
        for instruction in program:
            self.memory[address] = instruction
            address += 1

    def run(self):
        self.running = True
        while self.running:
            self.execute_instruction()

        print("Programa finalizado.")

# Ejemplo de uso:
pc = VirtualPC(tailscale_ip="100.101.102.103")  # Reemplaza con tu IP de Tailscale

# Programa de ejemplo:
# PRINT_IP  ; Muestra la IP de Tailscale
# HALT      ; Detiene el programa

program = [
    'PRINT_IP', 0,
    'HALT', 0
]

# Cargar el programa en la memoria
pc.load_program(program)

# Ejecutar el programa
pc.run()


# Contenido del archivo .github/workflows/virtual_pc.yml
github_actions_workflow = """
name: Virtual PC Simulation

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  run_simulation:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Install dependencies (si es necesario)
        run: |
          python -m pip install --upgrade pip

      - name: Run Virtual PC simulation
        run: python script.py

      - name: Output result
        run: |
          echo "Result of Virtual PC simulation:"
          cat output.txt
"""

# Guardar el script de Python en un archivo
with open("script.py", "w") as f:
    f.write("""
import os

# Código de la PC Virtual
class VirtualPC:
    def __init__(self, memory_size=1024, tailscale_ip="100.100.100.100"):
        self.memory = [0] * memory_size
        self.registers = {
            'PC': 0,
            'ACC': 0
        }
        self.instructions = {
            'LOAD': self.load,
            'ADD': self.add,
            'STORE': self.store,
            'HALT': self.halt,
            'PRINT_IP': self.print_ip  # Nueva instrucción para mostrar la IP
        }
        self.running = True
        self.tailscale_ip = tailscale_ip  # IP de Tailscale asignada

    def load(self, address):
        address = int(address)
        self.registers['ACC'] = self.memory[address]
        self.registers['PC'] += 2

    def add(self, address):
        address = int(address)
        self.registers['ACC'] += self.memory[address]
        self.registers['PC'] += 2

    def store(self, address):
        address = int(address)
        self.memory[address] = self.registers['ACC']
        self.registers['PC'] += 2

    def halt(self, _):
        self.running = False
        self.registers['PC'] += 1

    def print_ip(self, _):
        \"\"\"Muestra la IP de Tailscale.\"\"\"
        print(f"Tailscale IP: {self.tailscale_ip}")
        self.registers['PC'] += 1

    def execute_instruction(self):
        if not self.running:
            return

        instruction = self.memory[self.registers['PC']]
        instruction = str(instruction)
        operand = self.memory[self.registers['PC'] + 1]

        if instruction in self.instructions:
            self.instructions[instruction](operand)
        else:
            print(f"Instrucción desconocida: {instruction}")
            self.running = False

    def load_program(self, program):
        address = 0
        for instruction in program:
            self.memory[address] = instruction
            address += 1

    def run(self):
        self.running = True
        while self.running:
            self.execute_instruction()

        print("Programa finalizado.")

# Ejemplo de uso:
pc = VirtualPC(tailscale_ip="100.101.102.103")  # Reemplaza con tu IP de Tailscale

# Programa de ejemplo:
# PRINT_IP  ; Muestra la IP de Tailscale
# HALT      ; Detiene el programa

program = [
    'PRINT_IP', 0,
    'HALT', 0
]

# Cargar el programa en la memoria
pc.load_program(program)

# Ejecutar el programa
pc.run()
""")

# Guardar el workflow de GitHub Actions en un archivo
os.makedirs(".github/workflows", exist_ok=True)
with open(".github/workflows/virtual_pc.yml", "w") as f:
    f.write(github_actions_workflow)

print("Archivos 'script.py' y '.github/workflows/virtual_pc.yml' creados.")
print("Asegúrate de subir estos archivos a tu repositorio de GitHub.")
